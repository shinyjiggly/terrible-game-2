# ¥£¥ MeLT.ƒƒjƒ…[ƒŒƒCƒAƒEƒgƒeƒ“ƒvƒŒ[ƒg ¥£¥
#
# update 2007/ 7/22
#
#==============================================================================
# ƒJƒXƒ^ƒ}ƒCƒYƒ|ƒCƒ“ƒg
#==============================================================================
module XRXS_MeLT
  #
  # •\¦ƒgƒ‰ƒ“ƒWƒVƒ‡ƒ“
  #
  TRANS_TIME = 8
  TRANS_NAME = "" #"Graphics/Transitions/013-Square01"
  # [ƒƒjƒ…[ƒRƒ}ƒ“ƒh]
  COMMANDS = [
    "ƒAƒCƒeƒ€",   Scene_Item,
    "ƒXƒLƒ‹",     Scene_Skill,
    "‘•”õ",       Scene_Equip,
    "ƒXƒe[ƒ^ƒX", Scene_Status,
    "ƒZ[ƒu",     Scene_Save,
    "ƒQ[ƒ€I—¹", Scene_End
  ]
  # ƒAƒNƒ^[‘I‘ğ‚ğ—p‚¢‚È‚¢ƒV[ƒ“
  ACTOR_INDEX_DISADAPTED = [Scene_Item, Scene_Save, Scene_End]
  #
  # ƒJ[ƒ\ƒ‹ƒtƒ@ƒCƒ‹–¼ (Windowskin)
  #
  CURSOR_SKIN  = "MenuCursor"
  CURSOR_SKIN2 = "MenuCursor2"
  #
  # ”wŒiİ’è
  #
  USE_MAP    = true      # ”wŒi‚Éƒ}ƒbƒv‚ğ•\¦
  BG_TITLE  = "MenuBack" # ”wŒi‰æ‘œ (Titles)
  B_OPACITY = 160        # ”wŒi•s“§–¾“x
  #
  # ƒTƒCƒhƒRƒ}ƒ“ƒh
  #
  SIDE_KEY   = nil          # Input::RIGHT ‚È‚Ç@ƒL[w’è‚Å—LŒøBnil‚Å–³Œø‰»
  SIDE_SCENE = nil          # nil ‚Åƒp[ƒeƒB“ü‚ê‘Ö‚¦, ƒV[ƒ“‚àw’è‰Â
  #
  # [ƒAƒNƒ^[—§‚¿ŠGƒtƒ@ƒCƒ‹–¼]
  #  ( ƒAƒNƒ^[ID=>ƒtƒ@ƒCƒ‹–¼ ƒnƒbƒVƒ… 
  #     —áF2=>"Stand_2", ‚È‚Ç)
  #
  STAND_NAMES = {
    
  }
end
#==============================================================================
# —§‚¿ŠGƒtƒ@ƒCƒ‹–¼‚Ìæ“¾
#==============================================================================
class Game_Actor < Game_Battler
  def stand_name
    return XRXS_MeLT::STAND_NAMES[self.id].to_s
  end
end
#==============================================================================
# ƒƒjƒ…[ƒJ[ƒ\ƒ‹ˆê‹L‰¯ / MeLTİ’è
#==============================================================================
class Game_Temp
  attr_accessor :menu_index
end
module XRXS_MeLT
  # ƒƒjƒ…[ƒRƒ}ƒ“ƒh@ƒV[ƒ“/•¶š
  def self.commands
    set = []
    for i in 0...COMMANDS.size/2
      set.push(COMMANDS[i * 2 + 1])
    end
    return set
  end
  def self.captions
    set = []
    for i in 0...COMMANDS.size/2
      set.push(COMMANDS[i * 2])
    end
    return set
  end
end
#==============================================================================
# --- ƒƒjƒ…[ƒŒƒCƒAƒEƒg Šg’£’è‹` ---
#==============================================================================
class Scene_Menu
  #--------------------------------------------------------------------------
  # › ƒEƒBƒ“ƒhƒE‚Ìì¬
  #--------------------------------------------------------------------------
  def make_windows # 
    @bg_sprite = Spriteset_Map.new if XRXS_MeLT::USE_MAP
    sprite = Sprite.new
    sprite.bitmap = RPG::Cache.title(XRXS_MeLT::BG_TITLE)
    sprite.z = 1
    sprite.opacity = XRXS_MeLT::B_OPACITY
    @sprites.push(sprite)
  end
  def dispose_windows
    @bg_sprite.dispose if @bg_sprite != nil
  end
end
#==============================================================================
# ¡ Scene_Menu
#==============================================================================
class Scene_Menu
  #--------------------------------------------------------------------------
  # œ ƒIƒuƒWƒFƒNƒg‰Šú‰»
  #--------------------------------------------------------------------------
  def initialize(menu_index = 0)
    @menu_index = $game_temp.menu_index.to_i
  end
  #--------------------------------------------------------------------------
  # œ ƒƒCƒ“ˆ—
  #--------------------------------------------------------------------------
  def main
    # ƒRƒ}ƒ“ƒhƒEƒBƒ“ƒhƒE‚ğì¬
    @command_window = Window_MenuCommand.new
    @command_window.index = @menu_index
    # ƒXƒe[ƒ^ƒXƒEƒBƒ“ƒhƒE‚ğì¬
    @status_window = Window_MenuStatus.new
    # ‰Šú‰»
    @slideout_count= 0
    @next_scene_actor_index = nil
    # ƒJ[ƒ\ƒ‹‚Ìì¬
    @cursor2 = Sprite_MenuCursor.new(XRXS_MeLT::CURSOR_SKIN2)
    @cursor2.visible = false
    @cursor  = Sprite_MenuCursor.new(XRXS_MeLT::CURSOR_SKIN)
    @sprites = [@cursor2, @cursor]
    # ƒEƒBƒ“ƒhƒE‚ğì¬
    @windows = []
    @windows.push(@command_window)
    @windows.push(@status_window)
    make_windows
    # ƒgƒ‰ƒ“ƒWƒVƒ‡ƒ“Às
    Graphics.transition(XRXS_MeLT::TRANS_TIME, XRXS_MeLT::TRANS_NAME)
    # ƒƒCƒ“ƒ‹[ƒv
    loop do
      # ƒQ[ƒ€‰æ–Ê‚ğXV
      Graphics.update
      # “ü—Íî•ñ‚ğXV
      Input.update
      # ƒtƒŒ[ƒ€XV
      update
      # ‰æ–Ê‚ªØ‚è‘Ö‚í‚Á‚½‚çƒ‹[ƒv‚ğ’†’f
      if $scene != self
        break
      end
    end
    # ƒgƒ‰ƒ“ƒWƒVƒ‡ƒ“€”õ
    Graphics.freeze
    # ƒEƒBƒ“ƒhƒE‚ğ‰ğ•ú
    @windows.each{|window| window.dispose }
    @sprites.each{|sprite| sprite.dispose }
    dispose_windows
  end
  #--------------------------------------------------------------------------
  # œ ƒtƒŒ[ƒ€XV
  #--------------------------------------------------------------------------
  def update
    # ƒEƒBƒ“ƒhƒE‚ğXV
    @windows.each{|window| window.update }
    # ƒAƒNƒeƒBƒu‚ÈƒEƒBƒ“ƒhƒE‚ğŒŸõ
    active_window = nil
    for window in @windows
      if window.active
        active_window = window
        break
      end
    end
    # ƒJ[ƒ\ƒ‹ˆÊ’u‚ÌXV
    @cursor.visible = (active_window != nil)
    if active_window != nil
      cursor_dx = active_window.x + active_window.cursor_rect.x
      cursor_dy = active_window.y + active_window.cursor_rect.y + active_window.cursor_rect.height / 2
      distance_x = (cursor_dx - @cursor.x)
      distance_y = (cursor_dy - @cursor.y)
      speed = 24
      if distance_x.abs <= speed
        @cursor.x = cursor_dx
      else
        sign = (distance_x >= 0 ? 1 : -1)
        @cursor.x += speed * sign
      end
      if distance_y.abs <= speed
        @cursor.y = cursor_dy
      else
        sign = (distance_y >= 0 ? 1 : -1)
        @cursor.y += speed * sign
      end
      @cursor.visible = false if active_window.index == -1
    end
    # ƒXƒ‰ƒCƒhƒAƒEƒg
    if @slideout_count > 0
      @slideout_count -= 1
      if @slideout_count == 0
        # ‰æ–Ê‚ğØ‚è‘Ö‚¦
        if @next_scene_actor_index == nil
          $scene = @slideout_next_scene.new
        else
          $scene = @slideout_next_scene.new(@next_scene_actor_index)
        end
      end
      return
    end
    # ƒRƒ}ƒ“ƒhƒEƒBƒ“ƒhƒE‚ªƒAƒNƒeƒBƒu‚Ìê‡: update_command ‚ğŒÄ‚Ô
    if @command_window.active
      update_command
      return
    end
    # ƒXƒe[ƒ^ƒXƒEƒBƒ“ƒhƒE‚ªƒAƒNƒeƒBƒu‚Ìê‡: update_status ‚ğŒÄ‚Ô
    if @status_window.active
      update_status
      return
    end
  end
  #--------------------------------------------------------------------------
  # œ ƒtƒŒ[ƒ€XV (ƒRƒ}ƒ“ƒhƒEƒBƒ“ƒhƒE‚ªƒAƒNƒeƒBƒu‚Ìê‡)
  #--------------------------------------------------------------------------
  def update_command
    # B ƒ{ƒ^ƒ“‚ª‰Ÿ‚³‚ê‚½ê‡
    if Input.trigger?(Input::B)
      # ƒLƒƒƒ“ƒZƒ‹ SE ‚ğ‰‰‘t
      $game_system.se_play($data_system.cancel_se)
      # 
      @windows.each{|window| window.slideout! }
      @slideout_count = 8
      @slideout_next_scene = Scene_Map
      $game_temp.menu_index = 0
      return
    end
    # C ƒ{ƒ^ƒ“‚©ƒTƒCƒhƒL[‚ª‰Ÿ‚³‚ê‚½ê‡
    if Input.trigger?(Input::C) or
      (XRXS_MeLT::SIDE_KEY != nil and Input.trigger?(XRXS_MeLT::SIDE_KEY))
      # ƒp[ƒeƒBl”‚ª 0 l‚ÅAƒZ[ƒuAƒQ[ƒ€I—¹ˆÈŠO‚ÌƒRƒ}ƒ“ƒh‚Ìê‡
      if $game_party.actors.size == 0 and @command_window.index < 4
        # ƒuƒU[ SE ‚ğ‰‰‘t
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # ‰Ÿ‚³‚ê‚½ƒL[‚É‚æ‚Á‚ÄƒV[ƒ“‚ğæ“¾
      if Input.trigger?(Input::C)
        scene = XRXS_MeLT.commands[@command_window.index]
      else
        scene = XRXS_MeLT::SIDE_SCENE
        index = XRXS_MeLT.commands.index(XRXS_MeLT::SIDE_SCENE)
        @command_window.index = index == nil ? -1 : index
      end
      # ƒp[ƒeƒB“ü‚ê‘Ö‚¦‚Ìê‡
      if scene == nil
        # Œˆ’è SE ‚ğ‰‰‘t
        $game_system.se_play($data_system.decision_se)
        # ƒXƒe[ƒ^ƒXƒEƒBƒ“ƒhƒE‚ğƒAƒNƒeƒBƒu‚É‚·‚é
        @command_window.active = false
        @command_window.decide!
        @status_window.active = true
        @status_window.index = 0
        return
      end
      # ƒZ[ƒu‹Ö~‚Ìê‡
      if scene == Scene_Save and $game_system.save_disabled
        # ƒuƒU[ SE ‚ğ‰‰‘t
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      # w’èƒV[ƒ“‚Ö‚ÌØ‚è‘Ö‚¦
      if not XRXS_MeLT::ACTOR_INDEX_DISADAPTED.include?(scene)
        # Œˆ’è SE ‚ğ‰‰‘t
        $game_system.se_play($data_system.decision_se)
        # ƒXƒe[ƒ^ƒXƒEƒBƒ“ƒhƒE‚ğƒAƒNƒeƒBƒu‚É‚·‚é
        @command_window.active = false
        @command_window.decide!
        @status_window.active = true
        @status_window.index = 0
      elsif scene != nil
        # Œˆ’è  SE ‚ğ‰‰‘t
        $game_system.se_play($data_system.decision_se)
        # ƒƒjƒ…[ƒCƒ“ƒfƒbƒNƒX‚Ì•Û
        $game_temp.menu_index = @command_window.index
        # ‰æ–Ê‚ğØ‚è‘Ö‚¦
        @windows.each{|window| window.slideout! }
        @slideout_count = 8
        @slideout_next_scene = scene
      end
      return
    end
  end
  #--------------------------------------------------------------------------
  # œ ƒtƒŒ[ƒ€XV (ƒXƒe[ƒ^ƒXƒEƒBƒ“ƒhƒE‚ªƒAƒNƒeƒBƒu‚Ìê‡)
  #--------------------------------------------------------------------------
  def update_status
    # B ƒ{ƒ^ƒ“‚ª‰Ÿ‚³‚ê‚½ê‡
    if Input.trigger?(Input::B)
      # ƒLƒƒƒ“ƒZƒ‹ SE ‚ğ‰‰‘t
      $game_system.se_play($data_system.cancel_se)
      #
      if @status_window.index2 == -1
        # ƒRƒ}ƒ“ƒhƒEƒBƒ“ƒhƒE‚ğƒAƒNƒeƒBƒu‚É‚·‚é
        @command_window.active = true
        @command_window.cancel!
        @command_window.index = 0 if @command_window.index == -1
        @status_window.active = false
        @status_window.index = -1
        @next_scene_actor_index = nil
      else
        @status_window.index = @status_window.index2
        @status_window.index2 = -1
        @cursor2.visible = false
      end
      return
    end
    # C ƒ{ƒ^ƒ“‚ª‰Ÿ‚³‚ê‚½ê‡
    if Input.trigger?(Input::C)
      # w’è‚³‚ê‚½ƒV[ƒ“‚Ìæ“¾
      scene = @command_window.index == -1 ? nil : XRXS_MeLT.commands[@command_window.index]
      # nil ‚È‚ç‚Îƒƒjƒ…[‚Å‚Ìƒƒ“ƒo[“ü‚ê‘Ö‚¦
      if scene == nil
        # Œˆ’è  SE ‚ğ‰‰‘t
        $game_system.se_play($data_system.decision_se)
        if @status_window.index2 == -1
          @status_window.index2 = @status_window.index
          @cursor2.x = @status_window.x + @status_window.cursor_rect.x
          @cursor2.y = @status_window.y + @status_window.cursor_rect.y + @status_window.cursor_rect.height / 2
          @cursor2.visible = true
        else
          @cursor2.visible = false
          # ƒƒ“ƒo[‚Ì“ü‚ê‘Ö‚¦“ñl–Ú‚ÌŒˆ’è‚Æ“ü‚ê‘Ö‚¦‚ÌÀs
          actor2 = $game_party.actors[@status_window.index]
          actor = $game_party.actors[@status_window.index2]
          $game_party.actors[@status_window.index2] = actor2
          $game_party.actors[@status_window.index] = actor
          @status_window.index = @status_window.index2
          @status_window.index2 = -1
          # ƒvƒŒƒCƒ„[‚ğƒŠƒtƒŒƒbƒVƒ…
          $game_player.refresh
          # ƒXƒe[ƒ^ƒXƒEƒBƒ“ƒhƒE‚ğƒŠƒtƒŒƒbƒVƒ…
          @status_window.refresh
        end
        return
      end
      # ‚±‚ÌƒAƒNƒ^[‚Ìs“®§ŒÀ‚ª 2 ˆÈã‚Ìê‡
      if scene == Scene_Skill and $game_party.actors[@status_window.index].restriction >= 2
        # ƒuƒU[ SE ‚ğ‰‰‘t
        $game_system.se_play($data_system.buzzer_se)
        return
      end
      @next_scene_actor_index = @status_window.index
      # Œˆ’è  SE ‚ğ‰‰‘t
      $game_system.se_play($data_system.decision_se)
      # ƒƒjƒ…[ƒCƒ“ƒfƒbƒNƒX‚Ì•Û
      $game_temp.menu_index = @command_window.index
      # ‰æ–Ê‚ğØ‚è‘Ö‚¦
      @windows.each{|window| window.slideout! }
      @slideout_count = 8
      @slideout_next_scene = scene
      return
    end
  end
end
#==============================================================================
# --- ƒJ[ƒ\ƒ‹ƒXƒvƒ‰ƒCƒg ---
#==============================================================================
class Sprite_MenuCursor < Sprite
  def initialize(skin)
    super()
    self.bitmap = RPG::Cache.windowskin(skin)
    self.ox = self.bitmap.rect.width - 20
    self.oy = self.bitmap.rect.height / 2 - 16
    self.x  = -64
    self.y  =  64
    self.z  = 205
  end
end
#==============================================================================
# --- XRXS. ƒEƒBƒ“ƒhƒEƒXƒ‰ƒCƒfƒBƒ“ƒO‹@\ ---
#==============================================================================
module XRXS_WindowSliding
  def initialize(x, y, w, h)
    super(x, y, w, h)
    self.contents_opacity = 0
    @slidein_count  = 4
    @slideout_count = 0
    @slide_x_speed = 8
    @slide_y_speed = 0
    @slide_x_limit = nil
    @slide_objects = [self]
  end
  def update
    super
    if @slidein_count > 0
      @slidein_count -= 1
      for object in @slide_objects
        object.x += @slide_x_speed
        object.y += @slide_y_speed
        object.x = [object.x, @slide_x_limit].min if @slide_x_limit != nil
        case object
        when Window
          object.contents_opacity += 64
        when Sprite
          object.opacity += 64
        end
      end
    elsif @slideout_count > 0
      @slideout_count -= 1
      for object in @slide_objects
        object.x -= @slide_x_speed
        object.y -= @slide_y_speed
        case object
        when Window
          object.contents_opacity -= 64
        when Sprite
          object.opacity -= 64
        end
      end
    end
  end
  def slideout!
    @slidein_count  = 0
    @slideout_count = 4
  end
end
#==============================================================================
#   Bitmapƒ‰ƒCƒuƒ‰ƒŠ --- draw_hemming_text ---  
#==============================================================================
class Bitmap
  def draw_hemming_text(x, y, w, h, text, align = 0, black_color = Color.new(0,0,0,255))
    original_color = self.font.color.dup
    self.font.color = black_color
    self.draw_text(x  , y  , w, h, text, align)
    self.draw_text(x  , y+2, w, h, text, align)
    self.draw_text(x+2, y+2, w, h, text, align)
    self.draw_text(x+2, y  , w, h, text, align)
    self.font.color = original_color
    self.draw_text(x+1, y+1, w, h, text, align)
  end
end
#==============================================================================
#   Bitmapƒ‰ƒCƒuƒ‰ƒŠ --- blt_number ---  
#==============================================================================
class Bitmap
  def blt_number(x, y, skin, number, opacity = 224)
    a_width = skin.rect.width / 10
    rect = Rect.new(0, 0, a_width, skin.rect.height)
    #
    numbers = [
      number/10000000%10,number/1000000%10,number/100000%10,number/10000%10,
      number/1000%10,   number/100%10,    number/10%10,    number%10
    ]
    display = false
    for i in 0...numbers.size
      n = numbers[i]
      display |= (n != 0 or i == numbers.size - 1)
      if display
        rect.x = n * a_width
        self.blt(x - (8-i) * a_width, y - skin.rect.height, skin, rect, opacity)
      end
      #x += a_width
    end
  end
end
